// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pulsar.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pulsar_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pulsar_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pulsar_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pulsar_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pulsar_2eproto;
namespace pb {
class AttrRecord;
class AttrRecordDefaultTypeInternal;
extern AttrRecordDefaultTypeInternal _AttrRecord_default_instance_;
class Cell;
class CellDefaultTypeInternal;
extern CellDefaultTypeInternal _Cell_default_instance_;
class DeleteMsg;
class DeleteMsgDefaultTypeInternal;
extern DeleteMsgDefaultTypeInternal _DeleteMsg_default_instance_;
class FieldValue;
class FieldValueDefaultTypeInternal;
extern FieldValueDefaultTypeInternal _FieldValue_default_instance_;
class InsertMsg;
class InsertMsgDefaultTypeInternal;
extern InsertMsgDefaultTypeInternal _InsertMsg_default_instance_;
class PulsarMessage;
class PulsarMessageDefaultTypeInternal;
extern PulsarMessageDefaultTypeInternal _PulsarMessage_default_instance_;
class RowValue;
class RowValueDefaultTypeInternal;
extern RowValueDefaultTypeInternal _RowValue_default_instance_;
class SearchMsg;
class SearchMsgDefaultTypeInternal;
extern SearchMsgDefaultTypeInternal _SearchMsg_default_instance_;
class SearchResultMsg;
class SearchResultMsgDefaultTypeInternal;
extern SearchResultMsgDefaultTypeInternal _SearchResultMsg_default_instance_;
class SegmentRecord;
class SegmentRecordDefaultTypeInternal;
extern SegmentRecordDefaultTypeInternal _SegmentRecord_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class TestData;
class TestDataDefaultTypeInternal;
extern TestDataDefaultTypeInternal _TestData_default_instance_;
class VectorParam;
class VectorParamDefaultTypeInternal;
extern VectorParamDefaultTypeInternal _VectorParam_default_instance_;
class VectorRecord;
class VectorRecordDefaultTypeInternal;
extern VectorRecordDefaultTypeInternal _VectorRecord_default_instance_;
class VectorRowRecord;
class VectorRowRecordDefaultTypeInternal;
extern VectorRowRecordDefaultTypeInternal _VectorRowRecord_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::AttrRecord* Arena::CreateMaybeMessage<::pb::AttrRecord>(Arena*);
template<> ::pb::Cell* Arena::CreateMaybeMessage<::pb::Cell>(Arena*);
template<> ::pb::DeleteMsg* Arena::CreateMaybeMessage<::pb::DeleteMsg>(Arena*);
template<> ::pb::FieldValue* Arena::CreateMaybeMessage<::pb::FieldValue>(Arena*);
template<> ::pb::InsertMsg* Arena::CreateMaybeMessage<::pb::InsertMsg>(Arena*);
template<> ::pb::PulsarMessage* Arena::CreateMaybeMessage<::pb::PulsarMessage>(Arena*);
template<> ::pb::RowValue* Arena::CreateMaybeMessage<::pb::RowValue>(Arena*);
template<> ::pb::SearchMsg* Arena::CreateMaybeMessage<::pb::SearchMsg>(Arena*);
template<> ::pb::SearchResultMsg* Arena::CreateMaybeMessage<::pb::SearchResultMsg>(Arena*);
template<> ::pb::SegmentRecord* Arena::CreateMaybeMessage<::pb::SegmentRecord>(Arena*);
template<> ::pb::Status* Arena::CreateMaybeMessage<::pb::Status>(Arena*);
template<> ::pb::TestData* Arena::CreateMaybeMessage<::pb::TestData>(Arena*);
template<> ::pb::VectorParam* Arena::CreateMaybeMessage<::pb::VectorParam>(Arena*);
template<> ::pb::VectorRecord* Arena::CreateMaybeMessage<::pb::VectorRecord>(Arena*);
template<> ::pb::VectorRowRecord* Arena::CreateMaybeMessage<::pb::VectorRowRecord>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum ErrorCode : int {
  SUCCESS = 0,
  UNEXPECTED_ERROR = 1,
  CONNECT_FAILED = 2,
  PERMISSION_DENIED = 3,
  COLLECTION_NOT_EXISTS = 4,
  ILLEGAL_ARGUMENT = 5,
  ILLEGAL_DIMENSION = 7,
  ILLEGAL_INDEX_TYPE = 8,
  ILLEGAL_COLLECTION_NAME = 9,
  ILLEGAL_TOPK = 10,
  ILLEGAL_ROWRECORD = 11,
  ILLEGAL_VECTOR_ID = 12,
  ILLEGAL_SEARCH_RESULT = 13,
  FILE_NOT_FOUND = 14,
  META_FAILED = 15,
  CACHE_FAILED = 16,
  CANNOT_CREATE_FOLDER = 17,
  CANNOT_CREATE_FILE = 18,
  CANNOT_DELETE_FOLDER = 19,
  CANNOT_DELETE_FILE = 20,
  BUILD_INDEX_ERROR = 21,
  ILLEGAL_NLIST = 22,
  ILLEGAL_METRIC_TYPE = 23,
  OUT_OF_MEMORY = 24,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = SUCCESS;
constexpr ErrorCode ErrorCode_MAX = OUT_OF_MEMORY;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    const std::string& name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum DataType : int {
  NONE = 0,
  BOOL = 1,
  INT8 = 2,
  INT16 = 3,
  INT32 = 4,
  INT64 = 5,
  FLOAT = 10,
  DOUBLE = 11,
  STRING = 20,
  VECTOR_BINARY = 100,
  VECTOR_FLOAT = 101,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = NONE;
constexpr DataType DataType_MAX = VECTOR_FLOAT;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    const std::string& name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum OpType : int {
  Insert = 0,
  Delete = 1,
  Search = 2,
  TimeSync = 3,
  Key2Seg = 4,
  Statistics = 5,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OpType_IsValid(int value);
constexpr OpType OpType_MIN = Insert;
constexpr OpType OpType_MAX = Statistics;
constexpr int OpType_ARRAYSIZE = OpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpType_descriptor();
template<typename T>
inline const std::string& OpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpType_descriptor(), enum_t_value);
}
inline bool OpType_Parse(
    const std::string& name, OpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpType>(
    OpType_descriptor(), name, value);
}
// ===================================================================

class Status :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Status";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);

  // .pb.ErrorCode error_code = 1;
  void clear_error_code();
  ::pb::ErrorCode error_code() const;
  void set_error_code(::pb::ErrorCode value);

  // @@protoc_insertion_point(class_scope:pb.Status)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class SegmentRecord :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SegmentRecord) */ {
 public:
  SegmentRecord();
  virtual ~SegmentRecord();

  SegmentRecord(const SegmentRecord& from);
  SegmentRecord(SegmentRecord&& from) noexcept
    : SegmentRecord() {
    *this = ::std::move(from);
  }

  inline SegmentRecord& operator=(const SegmentRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentRecord& operator=(SegmentRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SegmentRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentRecord* internal_default_instance() {
    return reinterpret_cast<const SegmentRecord*>(
               &_SegmentRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SegmentRecord& a, SegmentRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentRecord* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SegmentRecord* New() const final {
    return CreateMaybeMessage<SegmentRecord>(nullptr);
  }

  SegmentRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SegmentRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SegmentRecord& from);
  void MergeFrom(const SegmentRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SegmentRecord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegInfoFieldNumber = 1,
  };
  // repeated string seg_info = 1;
  int seg_info_size() const;
  void clear_seg_info();
  const std::string& seg_info(int index) const;
  std::string* mutable_seg_info(int index);
  void set_seg_info(int index, const std::string& value);
  void set_seg_info(int index, std::string&& value);
  void set_seg_info(int index, const char* value);
  void set_seg_info(int index, const char* value, size_t size);
  std::string* add_seg_info();
  void add_seg_info(const std::string& value);
  void add_seg_info(std::string&& value);
  void add_seg_info(const char* value);
  void add_seg_info(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& seg_info() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_seg_info();

  // @@protoc_insertion_point(class_scope:pb.SegmentRecord)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> seg_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class VectorRowRecord :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.VectorRowRecord) */ {
 public:
  VectorRowRecord();
  virtual ~VectorRowRecord();

  VectorRowRecord(const VectorRowRecord& from);
  VectorRowRecord(VectorRowRecord&& from) noexcept
    : VectorRowRecord() {
    *this = ::std::move(from);
  }

  inline VectorRowRecord& operator=(const VectorRowRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorRowRecord& operator=(VectorRowRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VectorRowRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorRowRecord* internal_default_instance() {
    return reinterpret_cast<const VectorRowRecord*>(
               &_VectorRowRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VectorRowRecord& a, VectorRowRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorRowRecord* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorRowRecord* New() const final {
    return CreateMaybeMessage<VectorRowRecord>(nullptr);
  }

  VectorRowRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorRowRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VectorRowRecord& from);
  void MergeFrom(const VectorRowRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorRowRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.VectorRowRecord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatDataFieldNumber = 1,
    kBinaryDataFieldNumber = 2,
  };
  // repeated float float_data = 1;
  int float_data_size() const;
  void clear_float_data();
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      float_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_float_data();

  // bytes binary_data = 2;
  void clear_binary_data();
  const std::string& binary_data() const;
  void set_binary_data(const std::string& value);
  void set_binary_data(std::string&& value);
  void set_binary_data(const char* value);
  void set_binary_data(const void* value, size_t size);
  std::string* mutable_binary_data();
  std::string* release_binary_data();
  void set_allocated_binary_data(std::string* binary_data);

  // @@protoc_insertion_point(class_scope:pb.VectorRowRecord)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > float_data_;
  mutable std::atomic<int> _float_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class AttrRecord :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.AttrRecord) */ {
 public:
  AttrRecord();
  virtual ~AttrRecord();

  AttrRecord(const AttrRecord& from);
  AttrRecord(AttrRecord&& from) noexcept
    : AttrRecord() {
    *this = ::std::move(from);
  }

  inline AttrRecord& operator=(const AttrRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttrRecord& operator=(AttrRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AttrRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttrRecord* internal_default_instance() {
    return reinterpret_cast<const AttrRecord*>(
               &_AttrRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AttrRecord& a, AttrRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(AttrRecord* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AttrRecord* New() const final {
    return CreateMaybeMessage<AttrRecord>(nullptr);
  }

  AttrRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AttrRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AttrRecord& from);
  void MergeFrom(const AttrRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttrRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.AttrRecord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInt32ValueFieldNumber = 1,
    kInt64ValueFieldNumber = 2,
    kFloatValueFieldNumber = 3,
    kDoubleValueFieldNumber = 4,
  };
  // repeated int32 int32_value = 1;
  int int32_value_size() const;
  void clear_int32_value();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_value(int index) const;
  void set_int32_value(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      int32_value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_int32_value();

  // repeated int64 int64_value = 2;
  int int64_value_size() const;
  void clear_int64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value(int index) const;
  void set_int64_value(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      int64_value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_int64_value();

  // repeated float float_value = 3;
  int float_value_size() const;
  void clear_float_value();
  float float_value(int index) const;
  void set_float_value(int index, float value);
  void add_float_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      float_value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_float_value();

  // repeated double double_value = 4;
  int double_value_size() const;
  void clear_double_value();
  double double_value(int index) const;
  void set_double_value(int index, double value);
  void add_double_value(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      double_value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_double_value();

  // @@protoc_insertion_point(class_scope:pb.AttrRecord)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > int32_value_;
  mutable std::atomic<int> _int32_value_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > int64_value_;
  mutable std::atomic<int> _int64_value_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > float_value_;
  mutable std::atomic<int> _float_value_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > double_value_;
  mutable std::atomic<int> _double_value_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class VectorRecord :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.VectorRecord) */ {
 public:
  VectorRecord();
  virtual ~VectorRecord();

  VectorRecord(const VectorRecord& from);
  VectorRecord(VectorRecord&& from) noexcept
    : VectorRecord() {
    *this = ::std::move(from);
  }

  inline VectorRecord& operator=(const VectorRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorRecord& operator=(VectorRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VectorRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorRecord* internal_default_instance() {
    return reinterpret_cast<const VectorRecord*>(
               &_VectorRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VectorRecord& a, VectorRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorRecord* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorRecord* New() const final {
    return CreateMaybeMessage<VectorRecord>(nullptr);
  }

  VectorRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VectorRecord& from);
  void MergeFrom(const VectorRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.VectorRecord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 1,
  };
  // repeated .pb.VectorRowRecord records = 1;
  int records_size() const;
  void clear_records();
  ::pb::VectorRowRecord* mutable_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::VectorRowRecord >*
      mutable_records();
  const ::pb::VectorRowRecord& records(int index) const;
  ::pb::VectorRowRecord* add_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::VectorRowRecord >&
      records() const;

  // @@protoc_insertion_point(class_scope:pb.VectorRecord)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::VectorRowRecord > records_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class VectorParam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.VectorParam) */ {
 public:
  VectorParam();
  virtual ~VectorParam();

  VectorParam(const VectorParam& from);
  VectorParam(VectorParam&& from) noexcept
    : VectorParam() {
    *this = ::std::move(from);
  }

  inline VectorParam& operator=(const VectorParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorParam& operator=(VectorParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VectorParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorParam* internal_default_instance() {
    return reinterpret_cast<const VectorParam*>(
               &_VectorParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VectorParam& a, VectorParam& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorParam* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorParam* New() const final {
    return CreateMaybeMessage<VectorParam>(nullptr);
  }

  VectorParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VectorParam& from);
  void MergeFrom(const VectorParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.VectorParam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonFieldNumber = 1,
    kRowRecordFieldNumber = 2,
  };
  // string json = 1;
  void clear_json();
  const std::string& json() const;
  void set_json(const std::string& value);
  void set_json(std::string&& value);
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  std::string* mutable_json();
  std::string* release_json();
  void set_allocated_json(std::string* json);

  // .pb.VectorRecord row_record = 2;
  bool has_row_record() const;
  void clear_row_record();
  const ::pb::VectorRecord& row_record() const;
  ::pb::VectorRecord* release_row_record();
  ::pb::VectorRecord* mutable_row_record();
  void set_allocated_row_record(::pb::VectorRecord* row_record);

  // @@protoc_insertion_point(class_scope:pb.VectorParam)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  ::pb::VectorRecord* row_record_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class FieldValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.FieldValue) */ {
 public:
  FieldValue();
  virtual ~FieldValue();

  FieldValue(const FieldValue& from);
  FieldValue(FieldValue&& from) noexcept
    : FieldValue() {
    *this = ::std::move(from);
  }

  inline FieldValue& operator=(const FieldValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldValue& operator=(FieldValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FieldValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FieldValue* internal_default_instance() {
    return reinterpret_cast<const FieldValue*>(
               &_FieldValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FieldValue& a, FieldValue& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldValue* New() const final {
    return CreateMaybeMessage<FieldValue>(nullptr);
  }

  FieldValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FieldValue& from);
  void MergeFrom(const FieldValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.FieldValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNameFieldNumber = 1,
    kAttrRecordFieldNumber = 3,
    kVectorRecordFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string field_name = 1;
  void clear_field_name();
  const std::string& field_name() const;
  void set_field_name(const std::string& value);
  void set_field_name(std::string&& value);
  void set_field_name(const char* value);
  void set_field_name(const char* value, size_t size);
  std::string* mutable_field_name();
  std::string* release_field_name();
  void set_allocated_field_name(std::string* field_name);

  // .pb.AttrRecord attr_record = 3;
  bool has_attr_record() const;
  void clear_attr_record();
  const ::pb::AttrRecord& attr_record() const;
  ::pb::AttrRecord* release_attr_record();
  ::pb::AttrRecord* mutable_attr_record();
  void set_allocated_attr_record(::pb::AttrRecord* attr_record);

  // .pb.VectorRecord vector_record = 4;
  bool has_vector_record() const;
  void clear_vector_record();
  const ::pb::VectorRecord& vector_record() const;
  ::pb::VectorRecord* release_vector_record();
  ::pb::VectorRecord* mutable_vector_record();
  void set_allocated_vector_record(::pb::VectorRecord* vector_record);

  // .pb.DataType type = 2;
  void clear_type();
  ::pb::DataType type() const;
  void set_type(::pb::DataType value);

  // @@protoc_insertion_point(class_scope:pb.FieldValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_name_;
  ::pb::AttrRecord* attr_record_;
  ::pb::VectorRecord* vector_record_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class Cell :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Cell) */ {
 public:
  Cell();
  virtual ~Cell();

  Cell(const Cell& from);
  Cell(Cell&& from) noexcept
    : Cell() {
    *this = ::std::move(from);
  }

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cell& operator=(Cell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cell& default_instance();

  enum ValueCase {
    kInt32Value = 1,
    kInt64Value = 2,
    kFloatValue = 3,
    kDoubleValue = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cell* internal_default_instance() {
    return reinterpret_cast<const Cell*>(
               &_Cell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Cell& a, Cell& b) {
    a.Swap(&b);
  }
  inline void Swap(Cell* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cell* New() const final {
    return CreateMaybeMessage<Cell>(nullptr);
  }

  Cell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cell>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cell* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Cell";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInt32ValueFieldNumber = 1,
    kInt64ValueFieldNumber = 2,
    kFloatValueFieldNumber = 3,
    kDoubleValueFieldNumber = 4,
  };
  // int32 int32_value = 1;
  private:
  bool has_int32_value() const;
  public:
  void clear_int32_value();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_value() const;
  void set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int64 int64_value = 2;
  private:
  bool has_int64_value() const;
  public:
  void clear_int64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value() const;
  void set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  // float float_value = 3;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);

  // double double_value = 4;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:pb.Cell)
 private:
  class _Internal;
  void set_has_int32_value();
  void set_has_int64_value();
  void set_has_float_value();
  void set_has_double_value();

  inline bool has_value() const;
  inline void clear_has_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int32 int32_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
    float float_value_;
    double double_value_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class RowValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RowValue) */ {
 public:
  RowValue();
  virtual ~RowValue();

  RowValue(const RowValue& from);
  RowValue(RowValue&& from) noexcept
    : RowValue() {
    *this = ::std::move(from);
  }

  inline RowValue& operator=(const RowValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowValue& operator=(RowValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RowValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RowValue* internal_default_instance() {
    return reinterpret_cast<const RowValue*>(
               &_RowValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RowValue& a, RowValue& b) {
    a.Swap(&b);
  }
  inline void Swap(RowValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RowValue* New() const final {
    return CreateMaybeMessage<RowValue>(nullptr);
  }

  RowValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RowValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RowValue& from);
  void MergeFrom(const RowValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RowValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 2,
    kVecFieldNumber = 1,
  };
  // repeated .pb.Cell cell = 2;
  int cell_size() const;
  void clear_cell();
  ::pb::Cell* mutable_cell(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Cell >*
      mutable_cell();
  const ::pb::Cell& cell(int index) const;
  ::pb::Cell* add_cell();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Cell >&
      cell() const;

  // .pb.VectorRowRecord vec = 1;
  bool has_vec() const;
  void clear_vec();
  const ::pb::VectorRowRecord& vec() const;
  ::pb::VectorRowRecord* release_vec();
  ::pb::VectorRowRecord* mutable_vec();
  void set_allocated_vec(::pb::VectorRowRecord* vec);

  // @@protoc_insertion_point(class_scope:pb.RowValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Cell > cell_;
  ::pb::VectorRowRecord* vec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class PulsarMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PulsarMessage) */ {
 public:
  PulsarMessage();
  virtual ~PulsarMessage();

  PulsarMessage(const PulsarMessage& from);
  PulsarMessage(PulsarMessage&& from) noexcept
    : PulsarMessage() {
    *this = ::std::move(from);
  }

  inline PulsarMessage& operator=(const PulsarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulsarMessage& operator=(PulsarMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PulsarMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PulsarMessage* internal_default_instance() {
    return reinterpret_cast<const PulsarMessage*>(
               &_PulsarMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PulsarMessage& a, PulsarMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PulsarMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PulsarMessage* New() const final {
    return CreateMaybeMessage<PulsarMessage>(nullptr);
  }

  PulsarMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PulsarMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PulsarMessage& from);
  void MergeFrom(const PulsarMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulsarMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PulsarMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kCollectionNameFieldNumber = 1,
    kPartitionTagFieldNumber = 4,
    kTopicNameFieldNumber = 10,
    kVectorParamFieldNumber = 5,
    kSegmentsFieldNumber = 6,
    kEntityIdFieldNumber = 3,
    kTimestampFieldNumber = 7,
    kClientIdFieldNumber = 8,
    kPartitionIdFieldNumber = 11,
    kMsgTypeFieldNumber = 9,
  };
  // repeated .pb.FieldValue fields = 2;
  int fields_size() const;
  void clear_fields();
  ::pb::FieldValue* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::FieldValue >*
      mutable_fields();
  const ::pb::FieldValue& fields(int index) const;
  ::pb::FieldValue* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::FieldValue >&
      fields() const;

  // string collection_name = 1;
  void clear_collection_name();
  const std::string& collection_name() const;
  void set_collection_name(const std::string& value);
  void set_collection_name(std::string&& value);
  void set_collection_name(const char* value);
  void set_collection_name(const char* value, size_t size);
  std::string* mutable_collection_name();
  std::string* release_collection_name();
  void set_allocated_collection_name(std::string* collection_name);

  // string partition_tag = 4;
  void clear_partition_tag();
  const std::string& partition_tag() const;
  void set_partition_tag(const std::string& value);
  void set_partition_tag(std::string&& value);
  void set_partition_tag(const char* value);
  void set_partition_tag(const char* value, size_t size);
  std::string* mutable_partition_tag();
  std::string* release_partition_tag();
  void set_allocated_partition_tag(std::string* partition_tag);

  // string topic_name = 10;
  void clear_topic_name();
  const std::string& topic_name() const;
  void set_topic_name(const std::string& value);
  void set_topic_name(std::string&& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  std::string* mutable_topic_name();
  std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);

  // .pb.VectorParam vector_param = 5;
  bool has_vector_param() const;
  void clear_vector_param();
  const ::pb::VectorParam& vector_param() const;
  ::pb::VectorParam* release_vector_param();
  ::pb::VectorParam* mutable_vector_param();
  void set_allocated_vector_param(::pb::VectorParam* vector_param);

  // .pb.SegmentRecord segments = 6;
  bool has_segments() const;
  void clear_segments();
  const ::pb::SegmentRecord& segments() const;
  ::pb::SegmentRecord* release_segments();
  ::pb::SegmentRecord* mutable_segments();
  void set_allocated_segments(::pb::SegmentRecord* segments);

  // int64 entity_id = 3;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int64 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 timestamp = 7;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 client_id = 8;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::int64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 partition_id = 11;
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .pb.OpType msg_type = 9;
  void clear_msg_type();
  ::pb::OpType msg_type() const;
  void set_msg_type(::pb::OpType value);

  // @@protoc_insertion_point(class_scope:pb.PulsarMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::FieldValue > fields_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::pb::VectorParam* vector_param_;
  ::pb::SegmentRecord* segments_;
  ::PROTOBUF_NAMESPACE_ID::int64 entity_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 client_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  int msg_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class TestData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.TestData) */ {
 public:
  TestData();
  virtual ~TestData();

  TestData(const TestData& from);
  TestData(TestData&& from) noexcept
    : TestData() {
    *this = ::std::move(from);
  }

  inline TestData& operator=(const TestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestData& operator=(TestData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestData* internal_default_instance() {
    return reinterpret_cast<const TestData*>(
               &_TestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TestData& a, TestData& b) {
    a.Swap(&b);
  }
  inline void Swap(TestData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestData* New() const final {
    return CreateMaybeMessage<TestData>(nullptr);
  }

  TestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestData& from);
  void MergeFrom(const TestData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.TestData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:pb.TestData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class InsertMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.InsertMsg) */ {
 public:
  InsertMsg();
  virtual ~InsertMsg();

  InsertMsg(const InsertMsg& from);
  InsertMsg(InsertMsg&& from) noexcept
    : InsertMsg() {
    *this = ::std::move(from);
  }

  inline InsertMsg& operator=(const InsertMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertMsg& operator=(InsertMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertMsg* internal_default_instance() {
    return reinterpret_cast<const InsertMsg*>(
               &_InsertMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InsertMsg& a, InsertMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertMsg* New() const final {
    return CreateMaybeMessage<InsertMsg>(nullptr);
  }

  InsertMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertMsg& from);
  void MergeFrom(const InsertMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.InsertMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // int64 client_id = 1;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::int64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:pb.InsertMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class DeleteMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.DeleteMsg) */ {
 public:
  DeleteMsg();
  virtual ~DeleteMsg();

  DeleteMsg(const DeleteMsg& from);
  DeleteMsg(DeleteMsg&& from) noexcept
    : DeleteMsg() {
    *this = ::std::move(from);
  }

  inline DeleteMsg& operator=(const DeleteMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMsg& operator=(DeleteMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteMsg* internal_default_instance() {
    return reinterpret_cast<const DeleteMsg*>(
               &_DeleteMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteMsg& a, DeleteMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteMsg* New() const final {
    return CreateMaybeMessage<DeleteMsg>(nullptr);
  }

  DeleteMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteMsg& from);
  void MergeFrom(const DeleteMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.DeleteMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // int64 client_id = 1;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::int64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:pb.DeleteMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class SearchMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SearchMsg) */ {
 public:
  SearchMsg();
  virtual ~SearchMsg();

  SearchMsg(const SearchMsg& from);
  SearchMsg(SearchMsg&& from) noexcept
    : SearchMsg() {
    *this = ::std::move(from);
  }

  inline SearchMsg& operator=(const SearchMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMsg& operator=(SearchMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchMsg* internal_default_instance() {
    return reinterpret_cast<const SearchMsg*>(
               &_SearchMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SearchMsg& a, SearchMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchMsg* New() const final {
    return CreateMaybeMessage<SearchMsg>(nullptr);
  }

  SearchMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchMsg& from);
  void MergeFrom(const SearchMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SearchMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // int64 client_id = 1;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::int64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:pb.SearchMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// -------------------------------------------------------------------

class SearchResultMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SearchResultMsg) */ {
 public:
  SearchResultMsg();
  virtual ~SearchResultMsg();

  SearchResultMsg(const SearchResultMsg& from);
  SearchResultMsg(SearchResultMsg&& from) noexcept
    : SearchResultMsg() {
    *this = ::std::move(from);
  }

  inline SearchResultMsg& operator=(const SearchResultMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResultMsg& operator=(SearchResultMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchResultMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResultMsg* internal_default_instance() {
    return reinterpret_cast<const SearchResultMsg*>(
               &_SearchResultMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SearchResultMsg& a, SearchResultMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResultMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResultMsg* New() const final {
    return CreateMaybeMessage<SearchResultMsg>(nullptr);
  }

  SearchResultMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResultMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchResultMsg& from);
  void MergeFrom(const SearchResultMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResultMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SearchResultMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulsar_2eproto);
    return ::descriptor_table_pulsar_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // int64 client_id = 1;
  void clear_client_id();
  ::PROTOBUF_NAMESPACE_ID::int64 client_id() const;
  void set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:pb.SearchResultMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulsar_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Status

// .pb.ErrorCode error_code = 1;
inline void Status::clear_error_code() {
  error_code_ = 0;
}
inline ::pb::ErrorCode Status::error_code() const {
  // @@protoc_insertion_point(field_get:pb.Status.error_code)
  return static_cast< ::pb::ErrorCode >(error_code_);
}
inline void Status::set_error_code(::pb::ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:pb.Status.error_code)
}

// string reason = 2;
inline void Status::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Status::reason() const {
  // @@protoc_insertion_point(field_get:pb.Status.reason)
  return reason_.GetNoArena();
}
inline void Status::set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Status.reason)
}
inline void Status::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Status.reason)
}
inline void Status::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Status.reason)
}
inline void Status::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Status.reason)
}
inline std::string* Status::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:pb.Status.reason)
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Status::release_reason() {
  // @@protoc_insertion_point(field_release:pb.Status.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Status::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:pb.Status.reason)
}

// -------------------------------------------------------------------

// SegmentRecord

// repeated string seg_info = 1;
inline int SegmentRecord::seg_info_size() const {
  return seg_info_.size();
}
inline void SegmentRecord::clear_seg_info() {
  seg_info_.Clear();
}
inline const std::string& SegmentRecord::seg_info(int index) const {
  // @@protoc_insertion_point(field_get:pb.SegmentRecord.seg_info)
  return seg_info_.Get(index);
}
inline std::string* SegmentRecord::mutable_seg_info(int index) {
  // @@protoc_insertion_point(field_mutable:pb.SegmentRecord.seg_info)
  return seg_info_.Mutable(index);
}
inline void SegmentRecord::set_seg_info(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pb.SegmentRecord.seg_info)
  seg_info_.Mutable(index)->assign(value);
}
inline void SegmentRecord::set_seg_info(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.SegmentRecord.seg_info)
  seg_info_.Mutable(index)->assign(std::move(value));
}
inline void SegmentRecord::set_seg_info(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  seg_info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.SegmentRecord.seg_info)
}
inline void SegmentRecord::set_seg_info(int index, const char* value, size_t size) {
  seg_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.SegmentRecord.seg_info)
}
inline std::string* SegmentRecord::add_seg_info() {
  // @@protoc_insertion_point(field_add_mutable:pb.SegmentRecord.seg_info)
  return seg_info_.Add();
}
inline void SegmentRecord::add_seg_info(const std::string& value) {
  seg_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.SegmentRecord.seg_info)
}
inline void SegmentRecord::add_seg_info(std::string&& value) {
  seg_info_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.SegmentRecord.seg_info)
}
inline void SegmentRecord::add_seg_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  seg_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.SegmentRecord.seg_info)
}
inline void SegmentRecord::add_seg_info(const char* value, size_t size) {
  seg_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.SegmentRecord.seg_info)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SegmentRecord::seg_info() const {
  // @@protoc_insertion_point(field_list:pb.SegmentRecord.seg_info)
  return seg_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SegmentRecord::mutable_seg_info() {
  // @@protoc_insertion_point(field_mutable_list:pb.SegmentRecord.seg_info)
  return &seg_info_;
}

// -------------------------------------------------------------------

// VectorRowRecord

// repeated float float_data = 1;
inline int VectorRowRecord::float_data_size() const {
  return float_data_.size();
}
inline void VectorRowRecord::clear_float_data() {
  float_data_.Clear();
}
inline float VectorRowRecord::float_data(int index) const {
  // @@protoc_insertion_point(field_get:pb.VectorRowRecord.float_data)
  return float_data_.Get(index);
}
inline void VectorRowRecord::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.VectorRowRecord.float_data)
}
inline void VectorRowRecord::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:pb.VectorRowRecord.float_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorRowRecord::float_data() const {
  // @@protoc_insertion_point(field_list:pb.VectorRowRecord.float_data)
  return float_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorRowRecord::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.VectorRowRecord.float_data)
  return &float_data_;
}

// bytes binary_data = 2;
inline void VectorRowRecord::clear_binary_data() {
  binary_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VectorRowRecord::binary_data() const {
  // @@protoc_insertion_point(field_get:pb.VectorRowRecord.binary_data)
  return binary_data_.GetNoArena();
}
inline void VectorRowRecord::set_binary_data(const std::string& value) {
  
  binary_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.VectorRowRecord.binary_data)
}
inline void VectorRowRecord::set_binary_data(std::string&& value) {
  
  binary_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.VectorRowRecord.binary_data)
}
inline void VectorRowRecord::set_binary_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  binary_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.VectorRowRecord.binary_data)
}
inline void VectorRowRecord::set_binary_data(const void* value, size_t size) {
  
  binary_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.VectorRowRecord.binary_data)
}
inline std::string* VectorRowRecord::mutable_binary_data() {
  
  // @@protoc_insertion_point(field_mutable:pb.VectorRowRecord.binary_data)
  return binary_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VectorRowRecord::release_binary_data() {
  // @@protoc_insertion_point(field_release:pb.VectorRowRecord.binary_data)
  
  return binary_data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VectorRowRecord::set_allocated_binary_data(std::string* binary_data) {
  if (binary_data != nullptr) {
    
  } else {
    
  }
  binary_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binary_data);
  // @@protoc_insertion_point(field_set_allocated:pb.VectorRowRecord.binary_data)
}

// -------------------------------------------------------------------

// AttrRecord

// repeated int32 int32_value = 1;
inline int AttrRecord::int32_value_size() const {
  return int32_value_.size();
}
inline void AttrRecord::clear_int32_value() {
  int32_value_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AttrRecord::int32_value(int index) const {
  // @@protoc_insertion_point(field_get:pb.AttrRecord.int32_value)
  return int32_value_.Get(index);
}
inline void AttrRecord::set_int32_value(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_value_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AttrRecord.int32_value)
}
inline void AttrRecord::add_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_value_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AttrRecord.int32_value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
AttrRecord::int32_value() const {
  // @@protoc_insertion_point(field_list:pb.AttrRecord.int32_value)
  return int32_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
AttrRecord::mutable_int32_value() {
  // @@protoc_insertion_point(field_mutable_list:pb.AttrRecord.int32_value)
  return &int32_value_;
}

// repeated int64 int64_value = 2;
inline int AttrRecord::int64_value_size() const {
  return int64_value_.size();
}
inline void AttrRecord::clear_int64_value() {
  int64_value_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AttrRecord::int64_value(int index) const {
  // @@protoc_insertion_point(field_get:pb.AttrRecord.int64_value)
  return int64_value_.Get(index);
}
inline void AttrRecord::set_int64_value(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_value_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AttrRecord.int64_value)
}
inline void AttrRecord::add_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_value_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AttrRecord.int64_value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
AttrRecord::int64_value() const {
  // @@protoc_insertion_point(field_list:pb.AttrRecord.int64_value)
  return int64_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
AttrRecord::mutable_int64_value() {
  // @@protoc_insertion_point(field_mutable_list:pb.AttrRecord.int64_value)
  return &int64_value_;
}

// repeated float float_value = 3;
inline int AttrRecord::float_value_size() const {
  return float_value_.size();
}
inline void AttrRecord::clear_float_value() {
  float_value_.Clear();
}
inline float AttrRecord::float_value(int index) const {
  // @@protoc_insertion_point(field_get:pb.AttrRecord.float_value)
  return float_value_.Get(index);
}
inline void AttrRecord::set_float_value(int index, float value) {
  float_value_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AttrRecord.float_value)
}
inline void AttrRecord::add_float_value(float value) {
  float_value_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AttrRecord.float_value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AttrRecord::float_value() const {
  // @@protoc_insertion_point(field_list:pb.AttrRecord.float_value)
  return float_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AttrRecord::mutable_float_value() {
  // @@protoc_insertion_point(field_mutable_list:pb.AttrRecord.float_value)
  return &float_value_;
}

// repeated double double_value = 4;
inline int AttrRecord::double_value_size() const {
  return double_value_.size();
}
inline void AttrRecord::clear_double_value() {
  double_value_.Clear();
}
inline double AttrRecord::double_value(int index) const {
  // @@protoc_insertion_point(field_get:pb.AttrRecord.double_value)
  return double_value_.Get(index);
}
inline void AttrRecord::set_double_value(int index, double value) {
  double_value_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.AttrRecord.double_value)
}
inline void AttrRecord::add_double_value(double value) {
  double_value_.Add(value);
  // @@protoc_insertion_point(field_add:pb.AttrRecord.double_value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
AttrRecord::double_value() const {
  // @@protoc_insertion_point(field_list:pb.AttrRecord.double_value)
  return double_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
AttrRecord::mutable_double_value() {
  // @@protoc_insertion_point(field_mutable_list:pb.AttrRecord.double_value)
  return &double_value_;
}

// -------------------------------------------------------------------

// VectorRecord

// repeated .pb.VectorRowRecord records = 1;
inline int VectorRecord::records_size() const {
  return records_.size();
}
inline void VectorRecord::clear_records() {
  records_.Clear();
}
inline ::pb::VectorRowRecord* VectorRecord::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:pb.VectorRecord.records)
  return records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::VectorRowRecord >*
VectorRecord::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:pb.VectorRecord.records)
  return &records_;
}
inline const ::pb::VectorRowRecord& VectorRecord::records(int index) const {
  // @@protoc_insertion_point(field_get:pb.VectorRecord.records)
  return records_.Get(index);
}
inline ::pb::VectorRowRecord* VectorRecord::add_records() {
  // @@protoc_insertion_point(field_add:pb.VectorRecord.records)
  return records_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::VectorRowRecord >&
VectorRecord::records() const {
  // @@protoc_insertion_point(field_list:pb.VectorRecord.records)
  return records_;
}

// -------------------------------------------------------------------

// VectorParam

// string json = 1;
inline void VectorParam::clear_json() {
  json_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VectorParam::json() const {
  // @@protoc_insertion_point(field_get:pb.VectorParam.json)
  return json_.GetNoArena();
}
inline void VectorParam::set_json(const std::string& value) {
  
  json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.VectorParam.json)
}
inline void VectorParam::set_json(std::string&& value) {
  
  json_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.VectorParam.json)
}
inline void VectorParam::set_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.VectorParam.json)
}
inline void VectorParam::set_json(const char* value, size_t size) {
  
  json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.VectorParam.json)
}
inline std::string* VectorParam::mutable_json() {
  
  // @@protoc_insertion_point(field_mutable:pb.VectorParam.json)
  return json_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VectorParam::release_json() {
  // @@protoc_insertion_point(field_release:pb.VectorParam.json)
  
  return json_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VectorParam::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json);
  // @@protoc_insertion_point(field_set_allocated:pb.VectorParam.json)
}

// .pb.VectorRecord row_record = 2;
inline bool VectorParam::has_row_record() const {
  return this != internal_default_instance() && row_record_ != nullptr;
}
inline void VectorParam::clear_row_record() {
  if (GetArenaNoVirtual() == nullptr && row_record_ != nullptr) {
    delete row_record_;
  }
  row_record_ = nullptr;
}
inline const ::pb::VectorRecord& VectorParam::row_record() const {
  const ::pb::VectorRecord* p = row_record_;
  // @@protoc_insertion_point(field_get:pb.VectorParam.row_record)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::VectorRecord*>(
      &::pb::_VectorRecord_default_instance_);
}
inline ::pb::VectorRecord* VectorParam::release_row_record() {
  // @@protoc_insertion_point(field_release:pb.VectorParam.row_record)
  
  ::pb::VectorRecord* temp = row_record_;
  row_record_ = nullptr;
  return temp;
}
inline ::pb::VectorRecord* VectorParam::mutable_row_record() {
  
  if (row_record_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::VectorRecord>(GetArenaNoVirtual());
    row_record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.VectorParam.row_record)
  return row_record_;
}
inline void VectorParam::set_allocated_row_record(::pb::VectorRecord* row_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete row_record_;
  }
  if (row_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      row_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, row_record, submessage_arena);
    }
    
  } else {
    
  }
  row_record_ = row_record;
  // @@protoc_insertion_point(field_set_allocated:pb.VectorParam.row_record)
}

// -------------------------------------------------------------------

// FieldValue

// string field_name = 1;
inline void FieldValue::clear_field_name() {
  field_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FieldValue::field_name() const {
  // @@protoc_insertion_point(field_get:pb.FieldValue.field_name)
  return field_name_.GetNoArena();
}
inline void FieldValue::set_field_name(const std::string& value) {
  
  field_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.FieldValue.field_name)
}
inline void FieldValue::set_field_name(std::string&& value) {
  
  field_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.FieldValue.field_name)
}
inline void FieldValue::set_field_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  field_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.FieldValue.field_name)
}
inline void FieldValue::set_field_name(const char* value, size_t size) {
  
  field_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.FieldValue.field_name)
}
inline std::string* FieldValue::mutable_field_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.FieldValue.field_name)
  return field_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FieldValue::release_field_name() {
  // @@protoc_insertion_point(field_release:pb.FieldValue.field_name)
  
  return field_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FieldValue::set_allocated_field_name(std::string* field_name) {
  if (field_name != nullptr) {
    
  } else {
    
  }
  field_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field_name);
  // @@protoc_insertion_point(field_set_allocated:pb.FieldValue.field_name)
}

// .pb.DataType type = 2;
inline void FieldValue::clear_type() {
  type_ = 0;
}
inline ::pb::DataType FieldValue::type() const {
  // @@protoc_insertion_point(field_get:pb.FieldValue.type)
  return static_cast< ::pb::DataType >(type_);
}
inline void FieldValue::set_type(::pb::DataType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.FieldValue.type)
}

// .pb.AttrRecord attr_record = 3;
inline bool FieldValue::has_attr_record() const {
  return this != internal_default_instance() && attr_record_ != nullptr;
}
inline void FieldValue::clear_attr_record() {
  if (GetArenaNoVirtual() == nullptr && attr_record_ != nullptr) {
    delete attr_record_;
  }
  attr_record_ = nullptr;
}
inline const ::pb::AttrRecord& FieldValue::attr_record() const {
  const ::pb::AttrRecord* p = attr_record_;
  // @@protoc_insertion_point(field_get:pb.FieldValue.attr_record)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::AttrRecord*>(
      &::pb::_AttrRecord_default_instance_);
}
inline ::pb::AttrRecord* FieldValue::release_attr_record() {
  // @@protoc_insertion_point(field_release:pb.FieldValue.attr_record)
  
  ::pb::AttrRecord* temp = attr_record_;
  attr_record_ = nullptr;
  return temp;
}
inline ::pb::AttrRecord* FieldValue::mutable_attr_record() {
  
  if (attr_record_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::AttrRecord>(GetArenaNoVirtual());
    attr_record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.FieldValue.attr_record)
  return attr_record_;
}
inline void FieldValue::set_allocated_attr_record(::pb::AttrRecord* attr_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete attr_record_;
  }
  if (attr_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      attr_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attr_record, submessage_arena);
    }
    
  } else {
    
  }
  attr_record_ = attr_record;
  // @@protoc_insertion_point(field_set_allocated:pb.FieldValue.attr_record)
}

// .pb.VectorRecord vector_record = 4;
inline bool FieldValue::has_vector_record() const {
  return this != internal_default_instance() && vector_record_ != nullptr;
}
inline void FieldValue::clear_vector_record() {
  if (GetArenaNoVirtual() == nullptr && vector_record_ != nullptr) {
    delete vector_record_;
  }
  vector_record_ = nullptr;
}
inline const ::pb::VectorRecord& FieldValue::vector_record() const {
  const ::pb::VectorRecord* p = vector_record_;
  // @@protoc_insertion_point(field_get:pb.FieldValue.vector_record)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::VectorRecord*>(
      &::pb::_VectorRecord_default_instance_);
}
inline ::pb::VectorRecord* FieldValue::release_vector_record() {
  // @@protoc_insertion_point(field_release:pb.FieldValue.vector_record)
  
  ::pb::VectorRecord* temp = vector_record_;
  vector_record_ = nullptr;
  return temp;
}
inline ::pb::VectorRecord* FieldValue::mutable_vector_record() {
  
  if (vector_record_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::VectorRecord>(GetArenaNoVirtual());
    vector_record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.FieldValue.vector_record)
  return vector_record_;
}
inline void FieldValue::set_allocated_vector_record(::pb::VectorRecord* vector_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vector_record_;
  }
  if (vector_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vector_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_record, submessage_arena);
    }
    
  } else {
    
  }
  vector_record_ = vector_record;
  // @@protoc_insertion_point(field_set_allocated:pb.FieldValue.vector_record)
}

// -------------------------------------------------------------------

// Cell

// int32 int32_value = 1;
inline bool Cell::has_int32_value() const {
  return value_case() == kInt32Value;
}
inline void Cell::set_has_int32_value() {
  _oneof_case_[0] = kInt32Value;
}
inline void Cell::clear_int32_value() {
  if (has_int32_value()) {
    value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cell::int32_value() const {
  // @@protoc_insertion_point(field_get:pb.Cell.int32_value)
  if (has_int32_value()) {
    return value_.int32_value_;
  }
  return 0;
}
inline void Cell::set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_int32_value()) {
    clear_value();
    set_has_int32_value();
  }
  value_.int32_value_ = value;
  // @@protoc_insertion_point(field_set:pb.Cell.int32_value)
}

// int64 int64_value = 2;
inline bool Cell::has_int64_value() const {
  return value_case() == kInt64Value;
}
inline void Cell::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void Cell::clear_int64_value() {
  if (has_int64_value()) {
    value_.int64_value_ = PROTOBUF_LONGLONG(0);
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Cell::int64_value() const {
  // @@protoc_insertion_point(field_get:pb.Cell.int64_value)
  if (has_int64_value()) {
    return value_.int64_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Cell::set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_int64_value()) {
    clear_value();
    set_has_int64_value();
  }
  value_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:pb.Cell.int64_value)
}

// float float_value = 3;
inline bool Cell::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Cell::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Cell::clear_float_value() {
  if (has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float Cell::float_value() const {
  // @@protoc_insertion_point(field_get:pb.Cell.float_value)
  if (has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Cell::set_float_value(float value) {
  if (!has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:pb.Cell.float_value)
}

// double double_value = 4;
inline bool Cell::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void Cell::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void Cell::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Cell::double_value() const {
  // @@protoc_insertion_point(field_get:pb.Cell.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void Cell::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:pb.Cell.double_value)
}

inline bool Cell::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Cell::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Cell::ValueCase Cell::value_case() const {
  return Cell::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RowValue

// .pb.VectorRowRecord vec = 1;
inline bool RowValue::has_vec() const {
  return this != internal_default_instance() && vec_ != nullptr;
}
inline void RowValue::clear_vec() {
  if (GetArenaNoVirtual() == nullptr && vec_ != nullptr) {
    delete vec_;
  }
  vec_ = nullptr;
}
inline const ::pb::VectorRowRecord& RowValue::vec() const {
  const ::pb::VectorRowRecord* p = vec_;
  // @@protoc_insertion_point(field_get:pb.RowValue.vec)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::VectorRowRecord*>(
      &::pb::_VectorRowRecord_default_instance_);
}
inline ::pb::VectorRowRecord* RowValue::release_vec() {
  // @@protoc_insertion_point(field_release:pb.RowValue.vec)
  
  ::pb::VectorRowRecord* temp = vec_;
  vec_ = nullptr;
  return temp;
}
inline ::pb::VectorRowRecord* RowValue::mutable_vec() {
  
  if (vec_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::VectorRowRecord>(GetArenaNoVirtual());
    vec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.RowValue.vec)
  return vec_;
}
inline void RowValue::set_allocated_vec(::pb::VectorRowRecord* vec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vec_;
  }
  if (vec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec, submessage_arena);
    }
    
  } else {
    
  }
  vec_ = vec;
  // @@protoc_insertion_point(field_set_allocated:pb.RowValue.vec)
}

// repeated .pb.Cell cell = 2;
inline int RowValue::cell_size() const {
  return cell_.size();
}
inline void RowValue::clear_cell() {
  cell_.Clear();
}
inline ::pb::Cell* RowValue::mutable_cell(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RowValue.cell)
  return cell_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Cell >*
RowValue::mutable_cell() {
  // @@protoc_insertion_point(field_mutable_list:pb.RowValue.cell)
  return &cell_;
}
inline const ::pb::Cell& RowValue::cell(int index) const {
  // @@protoc_insertion_point(field_get:pb.RowValue.cell)
  return cell_.Get(index);
}
inline ::pb::Cell* RowValue::add_cell() {
  // @@protoc_insertion_point(field_add:pb.RowValue.cell)
  return cell_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Cell >&
RowValue::cell() const {
  // @@protoc_insertion_point(field_list:pb.RowValue.cell)
  return cell_;
}

// -------------------------------------------------------------------

// PulsarMessage

// string collection_name = 1;
inline void PulsarMessage::clear_collection_name() {
  collection_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PulsarMessage::collection_name() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.collection_name)
  return collection_name_.GetNoArena();
}
inline void PulsarMessage::set_collection_name(const std::string& value) {
  
  collection_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.collection_name)
}
inline void PulsarMessage::set_collection_name(std::string&& value) {
  
  collection_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.PulsarMessage.collection_name)
}
inline void PulsarMessage::set_collection_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  collection_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.PulsarMessage.collection_name)
}
inline void PulsarMessage::set_collection_name(const char* value, size_t size) {
  
  collection_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.PulsarMessage.collection_name)
}
inline std::string* PulsarMessage::mutable_collection_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.PulsarMessage.collection_name)
  return collection_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PulsarMessage::release_collection_name() {
  // @@protoc_insertion_point(field_release:pb.PulsarMessage.collection_name)
  
  return collection_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PulsarMessage::set_allocated_collection_name(std::string* collection_name) {
  if (collection_name != nullptr) {
    
  } else {
    
  }
  collection_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collection_name);
  // @@protoc_insertion_point(field_set_allocated:pb.PulsarMessage.collection_name)
}

// repeated .pb.FieldValue fields = 2;
inline int PulsarMessage::fields_size() const {
  return fields_.size();
}
inline void PulsarMessage::clear_fields() {
  fields_.Clear();
}
inline ::pb::FieldValue* PulsarMessage::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PulsarMessage.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::FieldValue >*
PulsarMessage::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:pb.PulsarMessage.fields)
  return &fields_;
}
inline const ::pb::FieldValue& PulsarMessage::fields(int index) const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.fields)
  return fields_.Get(index);
}
inline ::pb::FieldValue* PulsarMessage::add_fields() {
  // @@protoc_insertion_point(field_add:pb.PulsarMessage.fields)
  return fields_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::FieldValue >&
PulsarMessage::fields() const {
  // @@protoc_insertion_point(field_list:pb.PulsarMessage.fields)
  return fields_;
}

// int64 entity_id = 3;
inline void PulsarMessage::clear_entity_id() {
  entity_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PulsarMessage::entity_id() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.entity_id)
  return entity_id_;
}
inline void PulsarMessage::set_entity_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  entity_id_ = value;
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.entity_id)
}

// string partition_tag = 4;
inline void PulsarMessage::clear_partition_tag() {
  partition_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PulsarMessage::partition_tag() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.partition_tag)
  return partition_tag_.GetNoArena();
}
inline void PulsarMessage::set_partition_tag(const std::string& value) {
  
  partition_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.partition_tag)
}
inline void PulsarMessage::set_partition_tag(std::string&& value) {
  
  partition_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.PulsarMessage.partition_tag)
}
inline void PulsarMessage::set_partition_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partition_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.PulsarMessage.partition_tag)
}
inline void PulsarMessage::set_partition_tag(const char* value, size_t size) {
  
  partition_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.PulsarMessage.partition_tag)
}
inline std::string* PulsarMessage::mutable_partition_tag() {
  
  // @@protoc_insertion_point(field_mutable:pb.PulsarMessage.partition_tag)
  return partition_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PulsarMessage::release_partition_tag() {
  // @@protoc_insertion_point(field_release:pb.PulsarMessage.partition_tag)
  
  return partition_tag_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PulsarMessage::set_allocated_partition_tag(std::string* partition_tag) {
  if (partition_tag != nullptr) {
    
  } else {
    
  }
  partition_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_tag);
  // @@protoc_insertion_point(field_set_allocated:pb.PulsarMessage.partition_tag)
}

// .pb.VectorParam vector_param = 5;
inline bool PulsarMessage::has_vector_param() const {
  return this != internal_default_instance() && vector_param_ != nullptr;
}
inline void PulsarMessage::clear_vector_param() {
  if (GetArenaNoVirtual() == nullptr && vector_param_ != nullptr) {
    delete vector_param_;
  }
  vector_param_ = nullptr;
}
inline const ::pb::VectorParam& PulsarMessage::vector_param() const {
  const ::pb::VectorParam* p = vector_param_;
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.vector_param)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::VectorParam*>(
      &::pb::_VectorParam_default_instance_);
}
inline ::pb::VectorParam* PulsarMessage::release_vector_param() {
  // @@protoc_insertion_point(field_release:pb.PulsarMessage.vector_param)
  
  ::pb::VectorParam* temp = vector_param_;
  vector_param_ = nullptr;
  return temp;
}
inline ::pb::VectorParam* PulsarMessage::mutable_vector_param() {
  
  if (vector_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::VectorParam>(GetArenaNoVirtual());
    vector_param_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.PulsarMessage.vector_param)
  return vector_param_;
}
inline void PulsarMessage::set_allocated_vector_param(::pb::VectorParam* vector_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vector_param_;
  }
  if (vector_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vector_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_param, submessage_arena);
    }
    
  } else {
    
  }
  vector_param_ = vector_param;
  // @@protoc_insertion_point(field_set_allocated:pb.PulsarMessage.vector_param)
}

// .pb.SegmentRecord segments = 6;
inline bool PulsarMessage::has_segments() const {
  return this != internal_default_instance() && segments_ != nullptr;
}
inline void PulsarMessage::clear_segments() {
  if (GetArenaNoVirtual() == nullptr && segments_ != nullptr) {
    delete segments_;
  }
  segments_ = nullptr;
}
inline const ::pb::SegmentRecord& PulsarMessage::segments() const {
  const ::pb::SegmentRecord* p = segments_;
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.segments)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::SegmentRecord*>(
      &::pb::_SegmentRecord_default_instance_);
}
inline ::pb::SegmentRecord* PulsarMessage::release_segments() {
  // @@protoc_insertion_point(field_release:pb.PulsarMessage.segments)
  
  ::pb::SegmentRecord* temp = segments_;
  segments_ = nullptr;
  return temp;
}
inline ::pb::SegmentRecord* PulsarMessage::mutable_segments() {
  
  if (segments_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::SegmentRecord>(GetArenaNoVirtual());
    segments_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.PulsarMessage.segments)
  return segments_;
}
inline void PulsarMessage::set_allocated_segments(::pb::SegmentRecord* segments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete segments_;
  }
  if (segments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      segments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segments, submessage_arena);
    }
    
  } else {
    
  }
  segments_ = segments;
  // @@protoc_insertion_point(field_set_allocated:pb.PulsarMessage.segments)
}

// int64 timestamp = 7;
inline void PulsarMessage::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PulsarMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.timestamp)
  return timestamp_;
}
inline void PulsarMessage::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.timestamp)
}

// int64 client_id = 8;
inline void PulsarMessage::clear_client_id() {
  client_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PulsarMessage::client_id() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.client_id)
  return client_id_;
}
inline void PulsarMessage::set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.client_id)
}

// .pb.OpType msg_type = 9;
inline void PulsarMessage::clear_msg_type() {
  msg_type_ = 0;
}
inline ::pb::OpType PulsarMessage::msg_type() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.msg_type)
  return static_cast< ::pb::OpType >(msg_type_);
}
inline void PulsarMessage::set_msg_type(::pb::OpType value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.msg_type)
}

// string topic_name = 10;
inline void PulsarMessage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PulsarMessage::topic_name() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.topic_name)
  return topic_name_.GetNoArena();
}
inline void PulsarMessage::set_topic_name(const std::string& value) {
  
  topic_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.topic_name)
}
inline void PulsarMessage::set_topic_name(std::string&& value) {
  
  topic_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.PulsarMessage.topic_name)
}
inline void PulsarMessage::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  topic_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.PulsarMessage.topic_name)
}
inline void PulsarMessage::set_topic_name(const char* value, size_t size) {
  
  topic_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.PulsarMessage.topic_name)
}
inline std::string* PulsarMessage::mutable_topic_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.PulsarMessage.topic_name)
  return topic_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PulsarMessage::release_topic_name() {
  // @@protoc_insertion_point(field_release:pb.PulsarMessage.topic_name)
  
  return topic_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PulsarMessage::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    
  } else {
    
  }
  topic_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:pb.PulsarMessage.topic_name)
}

// int64 partition_id = 11;
inline void PulsarMessage::clear_partition_id() {
  partition_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PulsarMessage::partition_id() const {
  // @@protoc_insertion_point(field_get:pb.PulsarMessage.partition_id)
  return partition_id_;
}
inline void PulsarMessage::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  partition_id_ = value;
  // @@protoc_insertion_point(field_set:pb.PulsarMessage.partition_id)
}

// -------------------------------------------------------------------

// TestData

// string id = 1;
inline void TestData::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TestData::id() const {
  // @@protoc_insertion_point(field_get:pb.TestData.id)
  return id_.GetNoArena();
}
inline void TestData::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.TestData.id)
}
inline void TestData::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.TestData.id)
}
inline void TestData::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.TestData.id)
}
inline void TestData::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.TestData.id)
}
inline std::string* TestData::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:pb.TestData.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TestData::release_id() {
  // @@protoc_insertion_point(field_release:pb.TestData.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TestData::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:pb.TestData.id)
}

// string name = 2;
inline void TestData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TestData::name() const {
  // @@protoc_insertion_point(field_get:pb.TestData.name)
  return name_.GetNoArena();
}
inline void TestData::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.TestData.name)
}
inline void TestData::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.TestData.name)
}
inline void TestData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.TestData.name)
}
inline void TestData::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.TestData.name)
}
inline std::string* TestData::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.TestData.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TestData::release_name() {
  // @@protoc_insertion_point(field_release:pb.TestData.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TestData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb.TestData.name)
}

// -------------------------------------------------------------------

// InsertMsg

// int64 client_id = 1;
inline void InsertMsg::clear_client_id() {
  client_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertMsg::client_id() const {
  // @@protoc_insertion_point(field_get:pb.InsertMsg.client_id)
  return client_id_;
}
inline void InsertMsg::set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:pb.InsertMsg.client_id)
}

// -------------------------------------------------------------------

// DeleteMsg

// int64 client_id = 1;
inline void DeleteMsg::clear_client_id() {
  client_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeleteMsg::client_id() const {
  // @@protoc_insertion_point(field_get:pb.DeleteMsg.client_id)
  return client_id_;
}
inline void DeleteMsg::set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:pb.DeleteMsg.client_id)
}

// -------------------------------------------------------------------

// SearchMsg

// int64 client_id = 1;
inline void SearchMsg::clear_client_id() {
  client_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchMsg::client_id() const {
  // @@protoc_insertion_point(field_get:pb.SearchMsg.client_id)
  return client_id_;
}
inline void SearchMsg::set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:pb.SearchMsg.client_id)
}

// -------------------------------------------------------------------

// SearchResultMsg

// int64 client_id = 1;
inline void SearchResultMsg::clear_client_id() {
  client_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchResultMsg::client_id() const {
  // @@protoc_insertion_point(field_get:pb.SearchResultMsg.client_id)
  return client_id_;
}
inline void SearchResultMsg::set_client_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:pb.SearchResultMsg.client_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ErrorCode>() {
  return ::pb::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::pb::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::DataType>() {
  return ::pb::DataType_descriptor();
}
template <> struct is_proto_enum< ::pb::OpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::OpType>() {
  return ::pb::OpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pulsar_2eproto
